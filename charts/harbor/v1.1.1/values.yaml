expose:
  # Set the way how to expose the service. Set the type as "ingress", 
  # "clusterIP", "nodePort" or "loadBalancer" and fill the information 
  # in the corresponding section
  type: ingress
  tls:
    # Enable the tls or not. Note: if the type is "ingress" and the tls 
    # is disabled, the port must be included in the command when pull/push
    # images. Refer to https://github.com/goharbor/harbor/issues/5291 
    # for the detail.
    enabled: true
    # Fill the name of secret if you want to use your own TLS certificate. 
    # The secret must contain keys named:
    # "tls.crt" - the certificate
    # "tls.key" - the private key
    # "ca.crt" - the certificate of CA
    # These files will be generated automatically if the "secretName" is not set
    secretName: ""
    # By default, the Notary service will use the same cert and key as
    # described above. Fill the name of secret if you want to use a 
    # separated one. Only needed when the type is "ingress".
    notarySecretName: ""
    # The commmon name used to generate the certificate, it's necessary
    # when the type isn't "ingress" and "secretName" is null
    commonName: ""
    tlsCrt: "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURIekNDQWdlZ0F3SUJBZ0lRY0ZGQ1RBNTMrMVR6WlVEbmo1VnFxekFOQmdrcWhraUc5dzBCQVFzRkFEQVUKTVJJd0VBWURWUVFERXdsNlkyeHZkV1F0WTJFd0hoY05NVGt3T0RFME1ETTFOelF5V2hjTk16a3dPREE1TURNMQpOelF5V2pBZ01SNHdIQVlEVlFRREV4VmpiM0psTG1oaGNtSnZjaTVqYkhWemRHVnlMbmN3Z2dFaU1BMEdDU3FHClNJYjNEUUVCQVFVQUE0SUJEd0F3Z2dFS0FvSUJBUURjQmx1aHlFYUQyR3htSXpmY29oR0k1UElreFBjNktOOUgKWC8yaVZOTHlyRkt6ZWtZbFY3RVlWUHZWU0FvaWFUd1djeE1rUXFaWHQ1eG52dUFpRnNaazhmZU1ZSlZRbmt4Swo0S3BVQitnRCtPc2o5SGtYdU9VQzgzMVNZdjlpc0VBazU5MDFGaVJ0TFBUeWczU1FBZXdENnNxZHJnTXlsKy9rCjVud0JMYTBDK3MxdmVmbVFkcko2UGJXYUQ0U2l3M0FJeno1eVIra0hqcFhHd0ZlYXl0QkV0bk1vVk0wVmpNNmgKYjhPL0JkZUc1R08xU1VDVzFJS2pmbUczZW8xQm13dE1XSjViSS9QdUdCZlpGTnVYRDg2cEpDeWxrdndMY1d3RApwVlRmSHJMb3RJTWpNR1l5dnlXSkozSVo0SktHWnladDlMb2FpaUl2NXN4SjIyejJjeXZwQWdNQkFBR2pZVEJmCk1BNEdBMVVkRHdFQi93UUVBd0lGb0RBZEJnTlZIU1VFRmpBVUJnZ3JCZ0VGQlFjREFRWUlLd1lCQlFVSEF3SXcKREFZRFZSMFRBUUgvQkFJd0FEQWdCZ05WSFJFRUdUQVhnaFZqYjNKbExtaGhjbUp2Y2k1amJIVnpkR1Z5TG5jdwpEUVlKS29aSWh2Y05BUUVMQlFBRGdnRUJBS01UU0MrNFFMZzhtdVBBNW1nYWlmYzVoQWI3NnU0QUVXNmI4VmVnCmFiU0FxWkpxeVY3aHBsQ0p6Z0tOeE14UnNSaHNmak00MHp1Y3VjMEpMZEtrdGoyZzduUkpubnVrVmdKTFFOVmYKb2pTR2UzODJvWXoyMHQvZms0NnZkRng2MGhaWUcwZ0pqazNTalZCZ2RQclJ5T25KUkJwbGY2dEphNnByK2NDLwpWc0JKWHZ6ekVOL0tRdzFSOUMrbzBXU2IrbGt2Z0dta2o0TzJRWGd1UjI4NXVtVERFVjVSbGl5dXF3N043VHM2Cm93ZU9uZlVpM2EyckFxTFdyVWxoTCtHUzlIekp6dHBvbzgvSEdDazRWcXZlMHNwY2tLajlJZjkwY3o3Z0g3UmcKNHc3T0Nvay9BZkhLUjNCalFpcDU4bVFrODlVKzIwemVSejBMUzBDbWVZVXhLcjQ9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K"
    tlsKey: "LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcEFJQkFBS0NBUUVBM0FaYm9jaEdnOWhzWmlNMzNLSVJpT1R5Sk1UM09pamZSMS85b2xUUzhxeFNzM3BHCkpWZXhHRlQ3MVVnS0ltazhGbk1USkVLbVY3ZWNaNzdnSWhiR1pQSDNqR0NWVUo1TVN1Q3FWQWZvQS9qckkvUjUKRjdqbEF2TjlVbUwvWXJCQUpPZmROUllrYlN6MDhvTjBrQUhzQStyS25hNERNcGZ2NU9aOEFTMnRBdnJOYjNuNQprSGF5ZWoyMW1nK0Vvc053Q004K2NrZnBCNDZWeHNCWG1zclFSTFp6S0ZUTkZZek9vVy9EdndYWGh1Ump0VWxBCmx0U0NvMzVodDNxTlFac0xURmllV3lQejdoZ1gyUlRibHcvT3FTUXNwWkw4QzNGc0E2VlUzeDZ5NkxTREl6Qm0KTXI4bGlTZHlHZUNTaG1jbWJmUzZHb29pTCtiTVNkdHM5bk1yNlFJREFRQUJBb0lCQVFEYVFraFZsU2syRXROOQpBa1NnemZoYzl0ZXBWK1h6UUtZMDFHanl4Zmc0R0c4MWNQN3lmaW5EL0ZHUWdoVGppOGE2Y2s2enNwWDEvOExjCk8wRjFMMmlBckhLblF3djdXL3hNYnM4bjZtdml2T0xzMk0vaWsxeEI4QzRLTXdBcDhySytxVzhMQVRzRFBneUMKSVpyWVc3KzNKd3IxSGJBNFdQWDArQnBjeE9XU1JFZDJxanhQN2RNdGtGeERYSzFKMzlDak50SHBKVVhBSTlUWgpPT2cycEUxZkNyd25NWW9IcEpDWHE2OXJ6OGtLVEJCZTI1MXBSbUJtU2tybEswdE92ZkJVdU0yQTlEMUN4RXBLCjc1RUxkZDRSME9NSW1GQW9HUExLOVNzVVhnM2FpRDBoZWhpTjM4ZFlUUnR5Y2ROUEFTNG05eWorajhUeDZwc1kKRkwrKzVLNEJBb0dCQVBpUFdHYkcvaVZBU28zQ05DY1MvQkxnakdnSXE2NzVTbUNnTkNkenpBZmYyZFB3MWxRUAoyNEE1TzQ4aU1CMGtNRU1BZkRyaDJaRUE2QTNGaGxQWGgzNUVBY2gvQ0RlMldnTVRJQ1ZWWkJmUWtyN3pldnBhCldlMGg3eXlmUmFER21kazBRYjlkOGp5RjhVaUJEWXNIQ0ppbEdpYUtBMzJDWVpRN0J5T3dKeTVCQW9HQkFPS2MKV3VGVlkxcWwxZDN6bVZGMmFqNnR1aGJZeVFvUGJRRFRMM21WQ084ekdYYkxxNmgyemExYXJ6UENsdkxKU1dZcApVUHdRVUhaWEVjUG5GOExRMGdLTXJocWFWQmVVR080R1E3eFdITGtTY3l6TmgrMTNNNnZGM2hnZE9PMStZTTRkCmFzRlBJWE1xZERBTWdQMkFDVzhRdFovUzhoZUdYRnhCWUJvdUV1T3BBb0dBWHRuTXdVTzBuaUIva3NNR1JkYnYKeklCVjlDbEM0cjJNelh5MUNrMGRFZkF4WHJoc0FaNGZoRG5TNlpjQlIwMlZBU3lCTzdNTjVGQzFQUFFnZzRRZQoxMmM2U3ZsMitGT2syOEdEcGR1Rkc3VmpHbTB0ZzdYUTFUWDY0RXRUTmJ3ejMzZ2FrdDFWNEJTNDg1TVR5UGNCCko4YnhTTDJvQVZBc3puVU1EMmxjT2tFQ2dZQTZhSXFVSWVvbDV6Q2tzTEVINmptZ1JpNzh6SXVrNkN6MFZYcWIKSCtyWm5KWW5wSDl1UUpEcTZjRFcyb1VGdHhRUUhQNGV1aVhER3RZZFpHY2ZjNnR0dE16N1ZtUHVYK0c5R0NoRgpWdnk0UnlVZ215azU3OHVGcnM1NzhLeEhxcGRSQ1F3SEgxcEQwT0Y1c1A5ZVY2NFd6bnZCNGlFOEp3bVBUZHB6ClpRVEJZUUtCZ1FDSHlEbzZOREhaaG1nVDJHRVBCTXA2MFJ0cUdsVmdsLzEzOUlTQnNad1IrejFRUGhWdXVjTGwKckl5QlpvNStSWUozaDNMcC9BSmNyeHlpRmI0K1Y4MG1SQkZrbjRmQ0tNVG96WGIwV2FybXVZUE9ld013akJmawpTY2JIWWxpeld6R2VEY0RROThZRTh4Y2kxaTc1ZDB3U2tCeXdxMm5Ka0hVZENwN0xrSThtcUE9PQotLS0tLUVORCBSU0EgUFJJVkFURSBLRVktLS0tLQo="
    caCrt: "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM5VENDQWQyZ0F3SUJBZ0lSQUt3T09OTS8vSXVBa3d1cjk1SStyQ0l3RFFZSktvWklodmNOQVFFTEJRQXcKRkRFU01CQUdBMVVFQXhNSmVtTnNiM1ZrTFdOaE1CNFhEVEU1TURneE5EQXhNelF4T1ZvWERUTTVNRGd3T1RBeApNelF4T1Zvd0ZERVNNQkFHQTFVRUF4TUplbU5zYjNWa0xXTmhNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DCkFROEFNSUlCQ2dLQ0FRRUF1bnNvVmtHWVBpeW91NkRTbEpoSDlWSUk1NjlITFRDSms5OXI2bHg4WXFvd2l4TysKZFUzalhrNVpWN1BDOHR0aXJCWlpxaVo4R2k4WFJzWmRrN1BvMkFjcHBXMTF2Q0s5V0JTelUxb3JQOGxBSkVWRgo3QVR5VkhBVGVHd0xtcHg5M1J1RjhBL1RTK2ZNWWpIb3hldWkvZ1JXV0tKL0lqR0xoV2dBT2Zwem5UTkk0OUk3CjhXcUpaQm9XTFoyWDROb3B5Mkl2cjUzZDdUcW44ZFN5OUJLSlRPMnRWVWhFMEN0U3U1RHBxcDA5L1lhdWdLaUkKTUd5b3BPU1JhY3ZBK283ZC9sbnMyc1pKcVc3ODNSbTlrekxjcDB2NFBWVFNBOXRSVGd4MUpnQ3owVEx2R3FrbgovdlloZHlEbHM1UTUzL2FmbkZGTmY4d1hrSGNmdUs5Tnk1eFRLUUlEQVFBQm8wSXdRREFPQmdOVkhROEJBZjhFCkJBTUNBcVF3SFFZRFZSMGxCQll3RkFZSUt3WUJCUVVIQXdFR0NDc0dBUVVGQndNQ01BOEdBMVVkRXdFQi93UUYKTUFNQkFmOHdEUVlKS29aSWh2Y05BUUVMQlFBRGdnRUJBSXo2Nnd0NnRQQTJOdyt1SEVOTFhVbnVOa0tVbFBadApqa0ZXRkdONjRYS3duZHNmcmlxZFpvQ2h2TU1zbWs3U3hMdG00UGlVbUlLSFUyb2NTQUJEVXVtSXdqNVpFOFhXCkZsYVBDSXg3dUsxSnJ0NnNrbVZLQ09MRE9tNGJPVEowM2svQk9LQW1YMkhZUVJzNTVrQlpZQjJlMTFpRkNsRXIKZVJKSnA4RnYydzU5dklCakdnZnFHK1E3TUNoWWhHZWw3MmxvOW11MzhRN2E4ck9saEtBajRTL0FwUTMxNGczbQorUkVreGt3UWVXNkE4K00vVkZVc2duUHBCelRzU2k2Snc5UG03WkkxNjVYekIzMURJMGNZT1hqNU5iV3BmOU5FClp5eHExQkxDaERNcUd2NzljYzFISm5MK0h4dis2ejRtUWtobDBxNzBSZG1YTk85elA3a1ViV3M9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K"
  ingress:
    hosts:
      core: core.harbor.cluster.w
      notary: notary.harbor.cluster.w
    # set to the type of ingress controller if it has specific requirements.
    # leave as `default` for most ingress controllers.
    # set to `gce` if using the GCE ingress controller
    controller: default
    annotations:
      ingress.kubernetes.io/ssl-redirect: "true"
      ingress.kubernetes.io/proxy-body-size: "0"
      nginx.ingress.kubernetes.io/ssl-redirect: "true"
      nginx.ingress.kubernetes.io/proxy-body-size: "0"
  clusterIP:
    # The name of ClusterIP service
    name: harbor
    ports:
      # The service port Harbor listens on when serving with HTTP
      httpPort: 80
      # The service port Harbor listens on when serving with HTTPS
      httpsPort: 443
      # The service port Notary listens on. Only needed when notary.enabled 
      # is set to true
      notaryPort: 4443
  nodePort:
    # The name of NodePort service
    name: harbor
    ports:
      http:
        # The service port Harbor listens on when serving with HTTP
        port: 80
        # The node port Harbor listens on when serving with HTTP
        nodePort: 30002
      https: 
        # The service port Harbor listens on when serving with HTTPS
        port: 443
        # The node port Harbor listens on when serving with HTTPS
        nodePort: 30003
      # Only needed when notary.enabled is set to true
      notary: 
        # The service port Notary listens on
        port: 4443
        # The node port Notary listens on
        nodePort: 30004
  loadBalancer:
    # The name of LoadBalancer service
    name: harbor
    ports:
      # The service port Harbor listens on when serving with HTTP
      httpPort: 80
      # The service port Harbor listens on when serving with HTTPS
      httpsPort: 443
      # The service port Notary listens on. Only needed when notary.enabled 
      # is set to true
      notaryPort: 4443

# The external URL for Harbor core service. It is used to
# 1) populate the docker/helm commands showed on portal
# 2) populate the token service URL returned to docker/notary client
# 
# Format: protocol://domain[:port]. Usually:
# 1) if "expose.type" is "ingress", the "domain" should be 
# the value of "expose.ingress.hosts.core"
# 2) if "expose.type" is "clusterIP", the "domain" should be
# the value of "expose.clusterIP.name"
# 3) if "expose.type" is "nodePort", the "domain" should be
# the IP address of k8s node 
# 
# If Harbor is deployed behind the proxy, set it as the URL of proxy
externalURL: https://core.harbor.cluster.w

# The persistence is enabled by default and a default StorageClass
# is needed in the k8s cluster to provision volumes dynamicly. 
# Specify another StorageClass in the "storageClass" or set "existingClaim"
# if you have already existing persistent volumes to use
#
# For storing images and charts, you can also use "azure", "gcs", "s3", 
# "swift" or "oss". Set it in the "imageChartStorage" section
persistence:
  enabled: true
  # Setting it to "keep" to avoid removing PVCs during a helm delete 
  # operation. Leaving it empty will delete PVCs after the chart deleted
  resourcePolicy: "keep"
  storageClass: lvm
  persistentVolumeClaim:
    registry:
      # Use the existing PVC which must be created manually before bound, 
      # and specify the "subPath" if the PVC is shared with other components
      existingClaim: ""
      # Specify the "storageClass" used to provision the volume. Or the default
      # StorageClass will be used(the default).
      # Set it to "-" to disable dynamic provisioning
      storageClass: ""
      subPath: ""
      accessMode: ReadWriteOnce
      size: 5Gi
    chartmuseum:
      existingClaim: ""
      storageClass: ""
      subPath: ""
      accessMode: ReadWriteOnce
      size: 5Gi
    jobservice:
      existingClaim: ""
      storageClass: ""
      subPath: ""
      accessMode: ReadWriteOnce
      size: 1Gi
    # If external database is used, the following settings for database will 
    # be ignored
    database:
      existingClaim: ""
      storageClass: ""
      subPath: ""
      accessMode: ReadWriteOnce
      size: 5Gi
    # If external Redis is used, the following settings for Redis will 
    # be ignored
    redis:
      existingClaim: ""
      storageClass: ""
      subPath: ""
      accessMode: ReadWriteOnce
      size: 2Gi
  # Define which storage backend is used for registry and chartmuseum to store
  # images and charts. Refer to 
  # https://github.com/docker/distribution/blob/master/docs/configuration.md#storage 
  # for the detail.
  imageChartStorage:
    # Specify whether to disable `redirect` for images and chart storage, for 
    # backends which not supported it (such as using minio for `s3` storage type), please disable 
    # it. To disable redirects, simply set `disableredirect` to `true` instead. 
    # Refer to 
    # https://github.com/docker/distribution/blob/master/docs/configuration.md#redirect  
    # for the detail.
    disableredirect: false
    # Specify the type of storage: "filesystem", "azure", "gcs", "s3", "swift", 
    # "oss" and fill the information needed in the corresponding section. The type
    # must be "filesystem" if you want to use persistent volumes for registry
    # and chartmuseum
    type: filesystem
    filesystem:
      rootdirectory: /storage
      #maxthreads: 100
    azure:
      accountname: accountname
      accountkey: base64encodedaccountkey
      container: containername
      #realm: core.windows.net
    gcs:
      bucket: bucketname
      # The base64 encoded json file which contains the key
      encodedkey: base64-encoded-json-key-file
      #rootdirectory: /gcs/object/name/prefix
      #chunksize: "5242880"
    s3:
      region: us-west-1
      bucket: bucketname
      #accesskey: awsaccesskey
      #secretkey: awssecretkey
      #regionendpoint: http://myobjects.local
      #encrypt: false
      #keyid: mykeyid
      #secure: true
      #v4auth: true
      #chunksize: "5242880"
      #rootdirectory: /s3/object/name/prefix
      #storageclass: STANDARD
    swift:
      authurl: https://storage.myprovider.com/v3/auth
      username: username
      password: password
      container: containername
      #region: fr
      #tenant: tenantname
      #tenantid: tenantid
      #domain: domainname
      #domainid: domainid
      #trustid: trustid
      #insecureskipverify: false
      #chunksize: 5M
      #prefix:
      #secretkey: secretkey
      #accesskey: accesskey
      #authversion: 3
      #endpointtype: public
      #tempurlcontainerkey: false
      #tempurlmethods:
    oss:
      accesskeyid: accesskeyid
      accesskeysecret: accesskeysecret
      region: regionname
      bucket: bucketname
      #endpoint: endpoint
      #internal: false
      #encrypt: false
      #secure: true
      #chunksize: 10M
      #rootdirectory: rootdirectory

imagePullPolicy: IfNotPresent

logLevel: debug
# The initial password of Harbor admin. Change it from portal after launching Harbor
harborAdminPassword: "Harbor12345"
# The secret key used for encryption. Must be a string of 16 chars.
secretKey: "not-a-secure-key"

# If expose the service via "ingress", the Nginx will not be used
nginx:
  image:
    repository: zdnscloud/goharbor-nginx-photon
    tag: v1.8.1
  replicas: 1
  # resources:
  #  requests:
  #    memory: 256Mi
  #    cpu: 100m
  nodeSelector: {}
  tolerations: []
  affinity: {}
  ## Additional deployment annotations
  podAnnotations: {}

portal:
  image:
    repository: zdnscloud/goharbor-harbor-portal
    tag: v1.8.1
  replicas: 1
# resources:
#  requests:
#    memory: 256Mi
#    cpu: 100m
  nodeSelector: {}
  tolerations: []
  affinity: {}
  ## Additional deployment annotations
  podAnnotations: {}

core:
  image:
    repository: zdnscloud/goharbor-harbor-core
    tag: v1.8.1
  replicas: 1
# resources:
#  requests:
#    memory: 256Mi
#    cpu: 100m
  nodeSelector: {}
  tolerations: []
  affinity: {}
  ## Additional deployment annotations
  podAnnotations: {}
  # Secret is used when core server communicates with other components.
  # If a secret key is not specified, Helm will generate one.
  # Must be a string of 16 chars.
  secret: ""
  # Fill the name of a kubernetes secret if you want to use your own
  # TLS certificate and private key for token encryption/decryption.
  # The secret must contain keys named:
  # "tls.crt" - the certificate
  # "tls.key" - the private key
  # The default key pair will be used if it isn't set
  secretName: ""

jobservice:
  image:
    repository: zdnscloud/goharbor-harbor-jobservice
    tag: v1.8.1
  replicas: 1
  maxJobWorkers: 10
  # The logger for jobs: "file", "database" or "stdout"
  jobLogger: file
# resources:
#   requests:
#     memory: 256Mi
#     cpu: 100m
  nodeSelector: {}
  tolerations: []
  affinity: {}
  ## Additional deployment annotations
  podAnnotations: {}
  # Secret is used when job service communicates with other components.
  # If a secret key is not specified, Helm will generate one.
  # Must be a string of 16 chars.
  secret: ""

registry:
  registry:
    image:
      repository: zdnscloud/goharbor-registry-photon
      tag: v2.7.1-patch-2819-v1.8.1
    # resources:
    #  requests:
    #    memory: 256Mi
    #    cpu: 100m
  controller:
    image:
      repository: zdnscloud/goharbor-harbor-registryctl
      tag: v1.8.1
    # resources:
    #  requests:
    #    memory: 256Mi
    #    cpu: 100m
  replicas: 1
  nodeSelector: {}
  tolerations: []
  affinity: {}
  ## Additional deployment annotations
  podAnnotations: {}
  # Secret is used to secure the upload state from client
  # and registry storage backend.
  # See: https://github.com/docker/distribution/blob/master/docs/configuration.md#http
  # If a secret key is not specified, Helm will generate one.
  # Must be a string of 16 chars.
  secret: ""

chartmuseum:
  enabled: true
  image:
    repository: zdnscloud/goharbor-chartmuseum-photon
    tag: v0.8.1-v1.8.1
  replicas: 1
  # resources:
  #  requests:
  #    memory: 256Mi
  #    cpu: 100m
  nodeSelector: {}
  tolerations: []
  affinity: {}
  ## Additional deployment annotations
  podAnnotations: {}

clair:
  enabled: true
  image:
    repository: zdnscloud/goharbor-clair-photon
    tag: v2.0.8-v1.8.1
  replicas: 1
  # The http(s) proxy used to update vulnerabilities database from internet
  httpProxy:
  httpsProxy:
  # The interval of clair updaters, the unit is hour, set to 0 to 
  # disable the updaters
  updatersInterval: 12
  # resources:
  #  requests:
  #    memory: 256Mi
  #    cpu: 100m
  nodeSelector: {}
  tolerations: []
  affinity: {}
  ## Additional deployment annotations
  podAnnotations: {}

notary:
  enabled: true
  server:
    image:
      repository: zdnscloud/goharbor-notary-server-photon
      tag: v0.6.1-v1.8.1
    replicas: 1
    # resources:
    #  requests:
    #    memory: 256Mi
    #    cpu: 100m
  signer:
    image:
      repository: zdnscloud/goharbor-notary-signer-photon
      tag: v0.6.1-v1.8.1
    replicas: 1
    # resources:
    #  requests:
    #    memory: 256Mi
    #    cpu: 100m
  nodeSelector: {}
  tolerations: []
  affinity: {}
  ## Additional deployment annotations
  podAnnotations: {}
  # Fill the name of a kubernetes secret if you want to use your own
  # TLS certificate authority, certificate and private key for notary
  # communications.
  # The secret must contain keys named tls.ca, tls.crt and tls.key that
  # contain the CA, certificate and private key.
  # They will be generated if not set.
  secretName: ""

database:
  # if external database is used, set "type" to "external"
  # and fill the connection informations in "external" section
  type: internal
  internal:
    image:
      repository: zdnscloud/goharbor-harbor-db
      tag: v1.8.1
    # The initial superuser password for internal database
    password: "zcloud-harbor-db"
    # resources:
    #  requests:
    #    memory: 256Mi
    #    cpu: 100m
    nodeSelector: {}
    tolerations: []
    affinity: {}
  external:
    host: "192.168.0.1"
    port: "5432"
    username: "user"
    password: "password"
    coreDatabase: "registry"
    clairDatabase: "clair"
    notaryServerDatabase: "notary_server"
    notarySignerDatabase: "notary_signer"
    sslmode: "disable"
  ## Additional deployment annotations
  podAnnotations: {}

redis:
  # if external Redis is used, set "type" to "external"
  # and fill the connection informations in "external" section
  type: internal
  internal:
    image:
      repository: zdnscloud/goharbor-redis-photon
      tag: v1.8.1
    # resources:
    #  requests:
    #    memory: 256Mi
    #    cpu: 100m
    nodeSelector: {}
    tolerations: []
    affinity: {}
  external:
    host: "192.168.0.2"
    port: "6379"
    # The "coreDatabaseIndex" must be "0" as the library Harbor
    # used doesn't support configuring it
    coreDatabaseIndex: "0"
    jobserviceDatabaseIndex: "1"
    registryDatabaseIndex: "2"
    chartmuseumDatabaseIndex: "3"
    password: ""
  ## Additional deployment annotations
  podAnnotations: {}